let spawn,dedent,isClean,isUpToDate,getUpdateMessage,findMergeBase,checkout,checkoutPrevious,discardChanges,log,runTest;_3da‍.x([["runPatchBuild",()=>runPatchBuild]]);_3da‍.w("yarn-or-npm",[["spawn",["spawn"],function(v){spawn=v}]]);_3da‍.w("ts-dedent",[["default",["dedent"],function(v){dedent=v}]]);_3da‍.w("../git/git",[["isClean",["isClean"],function(v){isClean=v}],["isUpToDate",["isUpToDate"],function(v){isUpToDate=v}],["getUpdateMessage",["getUpdateMessage"],function(v){getUpdateMessage=v}],["findMergeBase",["findMergeBase"],function(v){findMergeBase=v}],["checkout",["checkout"],function(v){checkout=v}],["checkoutPrevious",["checkoutPrevious"],function(v){checkoutPrevious=v}],["discardChanges",["discardChanges"],function(v){discardChanges=v}]]);_3da‍.w("../lib/log",[["default",["log"],function(v){log=v}]]);_3da‍.w("./index",[["runTest",["runTest"],function(v){runTest=v}]]);














const installDependencies = () => spawn.sync(['install'], { stdio: 'inherit' });

       async function runPatchBuild(options) {
  const [headRef, baseRef] = options.patchBuild;

  // Make sure the git repo is in a clean state (no changes / untracked files).
  if (!(await isClean())) {
    log.error(dedent`
      The git working directory must be clean before running a patch build.
        (use "git stash --include-untracked --keep-index" to stash changes before you continue)
    `);
    return { exitCode: 255 };
  }

  // Make sure both the head and base branches are up-to-date with the remote.
  if (!(await isUpToDate())) {
    log.error(await getUpdateMessage());
    return { exitCode: 255 };
  }

  // Get the merge base commit hash.
  log.info(`Looking up the merge base for ${headRef} ${baseRef}...`);
  const mergeBase = await findMergeBase(headRef, baseRef);
  if (!mergeBase) {
    log.error(dedent`
      Failed to retrieve the merge base. You may have specified an invalid base branch.
      Are you sure the head branch is a descendant (i.e. fork) of the base branch?
        (try running this command yourself: "git merge-base --all ${headRef} ${baseRef}")
    `);
    return { exitCode: 255 };
  }

  log.info(`Checking out merge base commit ${mergeBase}`);
  await checkout(mergeBase);

  try {
    log.info('Installing dependencies...');
    installDependencies(); // this might modify a lockfile

    log.info(`Starting patch build for ${baseRef}...`);
    return await runTest({ ...options, patchBaseRef: baseRef, patchHeadRef: headRef }); // await here is necessary
  } finally {
    log.info('Restoring workspace...');
    await discardChanges(); // we need a clean state before checkout
    await checkoutPrevious();
    installDependencies();
    await discardChanges(); // drop lockfile changes
  }
}
